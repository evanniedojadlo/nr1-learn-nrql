import NextSteps from '../lessons/NextSteps';
import Overview from '../lessons/Overview';
import AggregateQuery3 from '../lessons/AggregateQuery3';
import Extrapolate from '../lessons/Extrapolate';
import FacetCases from '../lessons/FacetCases';
import FilterToEventTypes from '../lessons/FilterToEventTypes';
import OverridingValues from '../lessons/OverridingValues';

const translate = {
  Introduction: {
    Title: 'はじめに',
    Contents: {
      P1: `
        レベル3へようこそ。ここまでよく付いてきてくれました！
        ご利用中の実際の状況でクエリの結果や説明の例をご覧いただくことで、
        データをパワフルに可視化する方法をより深く理解していただけるものと思います。
        （このコースのクエリを、ご利用中のアカウントの様々なイベントタイプで試していただき、
        そのパワーを実感してください！）
      `,
      P2: `
        それでは、次はより高度なコンセプトのご紹介をしましょう。
        これからご紹介する関数や機能は常に使うものではないかもしれませんが、
        使い慣れておくことをおすすめします。
        特定の課題や要件に立ち向かうために必要になるでしょう。
      `,
      P3: `
        このレベルでは、場合分けを使ったFACET、高度な集計関数、
        EXTRAPOLATEキーワードを使った値の取得、フィルタを使った集計関数、
        そして値のオーバーライドをご紹介します。
      `
    }
  },
  'Advanced aggregators': {
    Title: '高度な集計機能',
    Contents: {
      P1: `
        New Relicは様々な集計機能を提供しています。
        それぞれの関数はそれぞれ異なる、便利な目的を提供しています。
        このレッスンでは、Rate, Funnnel, Filter, Histogram, Apdexの集計関数を体験して、
        より高度な疑問の答えを見つけられるようになるでしょう。
      `,
      H2_1: '「単位時間当たり」を計算する',
      P2: `
        <code>rate()</code> 関数から始めてみましょう。
        この関数を使うことにより、単位時間当たりの頻度を可視化することができます。
        小さい時間間隔での頻度を長い時間範囲に渡って理解したいときに有用です。
      `,
      P3: `
        次の例では、過去1時間の範囲で、5分当たりの平均リクエスト数を取得できます。
        また、その前の1時間における5分当たりの平均リクエスト数と比較しています。
        このクエリでは <code>SINCE 1 hour ago</code> を指定して、この時間範囲における値を
        計算しています。
      `,
      P4: `
        <code>rate()</code> は時間間隔を指定することで、
        <em>1分当たりのリクエスト</em>や<em>1秒辺りのリクエスト数</em>を計算することもできます。
      `,
      H2_2: 'ファネル図',
      P5: `
        エンドユーザーの行動を分析するために、ファネル図をお使いの方も多いことでしょう。
        ファネル図を使うことで、複数のレコードに渡る属性値の発生率を追跡できます。
        ユーザーの進捗状況が定義された経路に沿ってどのように上手く進んでいるかを可視化するときによく使われ、
        特にカスタムアトリビュートと組み合わせて使うと強力です。
      `,
      P6: `
        どのくらいのユーザーがトップページを開き、次に他のページを開いているかを、
        <code>funnel()</code> 集計関数を使って可視化してみましょう。
        1つ目のパラメーターで、ユニークなものとして扱うアトリビュートを特定します。
        この例では、New Relic Browserは（cookieの利用を有効にしている場合）サイトを訪れるユーザーに対して
        それぞれ <code>session</code> IDを割り当て、記録しています。
        カスタムアトリビュートで独自のセッションIDをセットすることもできます。
      `,
      P7: `
        続くパラメーターで、ファネルの各ステップをどのように計算するかを指定します。
        "<code>, WHERE アトリビュート 演算子 値</code>" の形式で記述します。
        この例では、2つのステップを指定しています。
        まず、トップページを訪れるたユニークなユーザー数を求め、
        次に、他のページに遷移したユーザーの数を求めています。
        <em>ご利用のデータで妥当そうな結果が得られるか、試してみてください。</em>
      `,
      H2_3: '集計フィルタ',
      P8: `
        <code>filter()</code> は集計の結果に含まれるイベントをより制御できるようするもので、
        1つのクエリで複数のデータポイントを集計するときに威力を発揮します。
        この例では、 <code>filter()</code> を使ってTransactionイベントから
        ウェブトランザクションおよび非ウェブトランザクションそれぞれの値を返すようにしています。
      `,
      P9: `
        この結果は数値を返しており、結果をさらに演算させることもできます。
        例えば、全てのトランザクションに占めるウェブトランザクションの割合を求めるには、
        次のようなクエリになります：
      `,
      H2_4: 'ヒストグラム',
      P10: `
        ヒストグラムを使うと、データの分布をわかりやすく可視化できるようになります。
        単なる平均だけではなく、データポイントがどのような頻度で出現するかを理解するときに役立ちます。
        <code>histogram()</code> 関数は3つの引数を取ります：
        <ol type="1">
          <li>プロットしたい属性（durationなど）</li>
          <li>分析したい範囲の最大値（"1"の場合、1秒以下を分析する）</li>
          <li>グループ化するときのバケット数</li>
        </ol>
        次の例では、 <code>histogram()</code>を使って、
        0〜1秒のduration値に対して、50msずつに分割したバケットでグループ化したチャートを作っています。
        バケット数には20を指定しています。
        1秒を超えるdurationのものは、最後のバケットにまとめられます。
      `,
      H2_5: 'Apdex',
      P11: `
        <code>apdex()</code>関数を使うと、あらゆる数値（durationなど）のApdexスコアが計算できます。
        特定のトランザクションやカスタムアトリビュートの値に対するApdex値を計算することができるようになり、
        また、APMの設定を変えることなく、独自のApdex-T値を与えることもできます。
        次の例では、"duration"値に対して、Apdex−Tを0.08にしたときのApdex値を求めています：
      `,
      P12: `
        もちろん、<code>TIMESERIES</code> 句を指定して、範囲時間に渡るデータの変化をチャートにすることもできます。
        チャートには、「満足」「不満」「イライラ」の範囲も描画されます。
      `,
      H2_6: 'レッスンのまとめ',
      P13: `
        新たな可視化ツールである、<code>funnel()</code> と <code>histogram()</code> をご紹介しました。
        また、 <code>filter()</code> を使ってWHERE句でクエリを絞り込む方法と、
        <code>rate()</code> で属性の頻度を可視化する方法をご紹介しました。
      `,
      P14: `
        これらのクエリで、よりNRQLを使いこなすことができるようになります。
        Apdexは業界標準のスコアであり、多くの状況に適用できます。
        ファネル図は指定した経路の進捗状況を追跡できます。
        ヒストグラムはデータの分布を明確に可視化できます。
        フィルタは返却値を自在に絞り込むことができるようになります。
        次は、 <code>extrapolate</code> をご紹介しましょう。
      `
    }
  },
  'Using extrapolate': {
    Title: 'extrapolateを使用する',
    Contents: {
      P1: `
        New Relic Database (NRDB)は、膨大な量のデータを毎日、稲妻のようなスピードで受信し、処理しています。
        APMが大量のイベントデータを記録する際、New Relicエージェントはうまくサンプリングすることによって、
        実行中のアプリケーションへの影響を軽減しつつ、有意義なデータを継続的に収集するということを両立しています。
        通常、このような事態が発生するのは、あるイベントに大量のリクエストが集中したときに起こります。
        負荷分散された複数のインスタンスで上で複数のエージェントが稼働しているときには、
        ほとんど発生することはありません。
      `,
      P2: `
        では、実際に起ったときにどうするかについて見ていきましょう。
        <code>EXTRAPOLATE</code> 句は、New Relicに対してサンプリングの影響を数学的に補完させることができます。
        従って、あなたのシステムの実際の挙動に近い値が得られることになります。
        New Relicは上限値をどの程度超えたかという、特別な値を管理しています。
        それにより、統計的に精度の高い値を返すことができます。
      `,
      P3: `
        「もしかして、上限に引っかかっているかも？」と心配になったことはありますか？
        それなら、 <code>EXTRAPOLATE</code> 句を消して、クエリを実行してみましょう。
        結果が変わらなかったとしたら、上限は超えていないだろうと推測できます。
      `,
      H2_1: 'レッスンのまとめ',
      P4: `
        クエリの中で <code>EXTRAPOLATE</code> が指定された場合、
        該当するイベントとすべてのイベントとの割合が計算されます。
        この割合はサンプリングされなかったデータの近似を差し込む（extrapolate）ときに使われます。
        このキーワードは、すべてのクエリで有効になるわけではありません。
        サポートされていないクエリで指定されている場合、もしくはサンプリングされたデータではない場合、
        指定は無視されます。
      `,
      P5: `
        <code>EXTRAPOLATE</code> は、均質なデータ（スループットやエラーレートなど）に対して上手く動きます。
        個別の値を求めるようなクエリ（<code>uniqueCount()</code> や <code>uniques()</code> など）では、
        あまり上手く動きません。
        このキーワードは、下記の集計関数を使っているときに動作します：
      `
    }
  },
  'Facet cases': {
    Title: 'FACET CASES',
    Contents: {
      P1: `
      `,
      P2: `
      `,
      P3: `
      `,
      P4: `
      `,
      P5: `
      `,
      P6: `
      `,
      P7: `
      `,
      P8: `
      `,
      P9: `
      `,
      P10: `
      `
    }
  },
  'Filter by event type': {
    Title: 'イベントタイプでフィルタする',
    Contents: {
      P1: `
      `,
      P2: `
      `,
      P3: `
      `,
      P4: `
      `,
      P5: `
      `,
      P6: `
      `,
      P7: `
      `,
      P8: `
      `,
      P9: `
      `,
      P10: `
      `
    }
  },
  'Overriding values': {
    Title: '値をオーバーライドする',
    Contents: {
      P1: `
      `,
      P2: `
      `,
      P3: `
      `,
      P4: `
      `,
      P5: `
      `,
      P6: `
      `,
      P7: `
      `,
      P8: `
      `,
      P9: `
      `,
      P10: `
      `
    }
  },
  Summary: {
    Title: 'まとめ',
    Contents: {
      P1: `
      `,
      P2: `
      `,
      P3: `
      `,
      P4: `
      `,
      P5: `
      `,
      P6: `
      `,
      P7: `
      `,
      P8: `
      `,
      P9: `
      `,
      P10: `
      `
    }
  }
};

export default translate;
